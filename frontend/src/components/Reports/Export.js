// frontend/src/components/Reports/Export.js
import { jsPDF } from 'jspdf';
import html2canvas from 'html2canvas';

/**
 * Utility function to export report section to PDF
 * @param {HTMLElement} element - The DOM element to capture
 * @param {string} timeRange - The selected time range
 * @param {Date} generatedDate - The date when the report data was generated
 */
export const exportReportToPdf = async (element, timeRange, generatedDate) => {
  if (!element) {
    console.error('No element provided for export');
    return;
  }

  try {
    // Show export in progress message
    const loadingToast = showExportToast('Generating PDF, please wait...');
    
    // Create PDF document (A4 size)
    const pdf = new jsPDF('p', 'mm', 'a4');
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    
    // Add cover page
    addCoverPage(pdf, timeRange, generatedDate);
    
    // Capture the report section
    const canvas = await html2canvas(element, {
      scale: 2, // Higher scale for better quality
      useCORS: true,
      logging: false,
      allowTaint: true,
      backgroundColor: '#ffffff'
    });
    
    // Convert to image and get dimensions
    const imgData = canvas.toDataURL('image/jpeg', 0.7); // Lower quality to reduce file size
    const imgWidth = pageWidth - 20; // 10mm margin on each side
    const imgHeight = (canvas.height * imgWidth) / canvas.width;
    
    // Add report image to new page
    pdf.addPage();
    
    // Calculate how many pages we need for the report image
    let heightLeft = imgHeight;
    let position = 10; // Initial position from top (10mm margin)
    
    // Add first part of the image
    pdf.addImage(imgData, 'JPEG', 10, position, imgWidth, imgHeight);
    heightLeft -= (pageHeight - 20); // Subtract the height of the first page
    
    // Add subsequent pages if needed
    while (heightLeft > 0) {
      position = heightLeft - imgHeight; // Negative value to show the next part of the image
      pdf.addPage();
      pdf.addImage(imgData, 'JPEG', 10, position, imgWidth, imgHeight);
      heightLeft -= (pageHeight - 20);
    }
    
    // Save the PDF
    const fileName = `Security_Report_${formatDateForFileName(new Date())}.pdf`;
    pdf.save(fileName);
    
    // Hide loading toast and show success message
    hideToast(loadingToast);
    showExportToast('Report exported successfully!', 'success');
  } catch (error) {
    console.error('Error exporting PDF:', error);
    showExportToast('Error exporting report. Please try again.', 'error');
  }
};

/**
 * Add cover page to PDF with company logo and metadata
 * @param {jsPDF} pdf - The PDF document
 * @param {string} timeRange - The selected time range
 * @param {Date} generatedDate - The date when the report data was generated
 */
const addCoverPage = (pdf, timeRange, generatedDate) => {
  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight(); // Added this line
  const centerX = pageWidth / 2;
  
  // Add company logo placeholder
  pdf.setTextColor(60, 60, 60);
  pdf.setFontSize(24);
  pdf.setFont('helvetica', 'bold');
  pdf.text('Your Company Logo', centerX, 50, { align: 'center' });
  
  // Add rectangle around the logo area
  pdf.setDrawColor(200, 200, 200);
  pdf.setLineWidth(0.5);
  pdf.rect(centerX - 50, 35, 100, 30, 'S');
  
  // Add client logo placeholder
  pdf.setFontSize(18);
  pdf.text('Client Logo', centerX, 100, { align: 'center' });
  pdf.rect(centerX - 30, 85, 60, 25, 'S');
  
  // Add title
  pdf.setFontSize(28);
  pdf.setTextColor(40, 40, 40);
  pdf.text('Security Analysis Report', centerX, 140, { align: 'center' });
  
  // Add horizontal line
  pdf.setDrawColor(70, 130, 180);
  pdf.setLineWidth(1);
  pdf.line(40, 150, pageWidth - 40, 150);
  
  // Add metadata section
  pdf.setFontSize(12);
  pdf.setTextColor(80, 80, 80);
  pdf.setFont('helvetica', 'normal');
  
  const metadata = [
    { label: 'Time Range:', value: formatTimeRange(timeRange) },
    { label: 'Generated On:', value: generatedDate.toLocaleDateString() },
    { label: 'Generated At:', value: generatedDate.toLocaleTimeString() },
    { label: 'Generated By:', value: 'Security Logs Manager' },
    { label: 'Report Type:', value: 'Security Analytics' }
  ];
  
  let yPos = 170;
  metadata.forEach(item => {
    pdf.setFont('helvetica', 'bold');
    pdf.text(`${item.label}`, 40, yPos);
    pdf.setFont('helvetica', 'normal');
    pdf.text(`${item.value}`, 100, yPos);
    yPos += 10;
  });
  
  // Add explanatory text
  yPos += 10;
  pdf.setFontSize(11);
  pdf.text('This report provides an analysis of security events and ticket data for the', 40, yPos);
  yPos += 7;
  pdf.text('specified time period. It includes visualizations of event trends, severity', 40, yPos);
  yPos += 7;
  pdf.text('distributions, and top security entities to help identify potential security', 40, yPos);
  yPos += 7;
  pdf.text('concerns and operational patterns.', 40, yPos);
  
  // Add footer
  pdf.setFontSize(10);
  pdf.setTextColor(100, 100, 100);
  pdf.text('CONFIDENTIAL - FOR INTERNAL USE ONLY', centerX, pageHeight - 20, { align: 'center' });
  pdf.text(`Report ID: ${generateReportId()}`, centerX, pageHeight - 15, { align: 'center' });
  
  // Add page number
  pdf.setFontSize(10);
  pdf.text('Page 1', centerX, pageHeight - 10, { align: 'center' });
};

/**
 * Format time range for display
 * @param {string} timeRange - The selected time range
 * @returns {string} Formatted time range description
 */
const formatTimeRange = (timeRange) => {
  switch (timeRange) {
    case '15m': return 'Last 15 minutes';
    case '1h': return 'Last hour';
    case '4h': return 'Last 4 hours';
    case '12h': return 'Last 12 hours';
    case '24h': return 'Last 24 hours';
    case '3d': return 'Last 3 days';
    case '7d': return 'Last 7 days';
    case '15d': return 'Last 15 days';
    case '30d': return 'Last 30 days';
    case '90d': return 'Last 90 days';
    default:
      if (timeRange.startsWith('custom:')) {
        const parts = timeRange.split(':');
        if (parts.length === 3) {
          return `Custom range: ${parts[1].split('T')[0]} to ${parts[2].split('T')[0]}`;
        }
      }
      return 'Custom Range';
  }
};

/**
 * Format date for file name
 * @param {Date} date - The date to format
 * @returns {string} Date formatted for file name
 */
const formatDateForFileName = (date) => {
  return date.toISOString()
    .replace(/[:.]/g, '-')
    .replace('T', '_')
    .split('.')[0];
};

/**
 * Generate a unique report ID
 * @returns {string} Unique report ID
 */
const generateReportId = () => {
  return 'REP-' + Math.random().toString(36).substring(2, 10).toUpperCase();
};

/**
 * Show a toast notification for export progress/results
 * @param {string} message - The message to show
 * @param {string} type - The type of notification (info, success, error)
 * @returns {HTMLElement} The toast element
 */
const showExportToast = (message, type = 'info') => {
  // First, remove any existing toast
  const existingToast = document.getElementById('export-toast');
  if (existingToast) {
    document.body.removeChild(existingToast);
  }
  
  // Create toast element
  const toast = document.createElement('div');
  toast.id = 'export-toast';
  toast.style.position = 'fixed';
  toast.style.bottom = '20px';
  toast.style.right = '20px';
  toast.style.padding = '10px 20px';
  toast.style.borderRadius = '4px';
  toast.style.color = '#fff';
  toast.style.zIndex = '9999';
  toast.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
  toast.style.minWidth = '250px';
  toast.style.textAlign = 'center';
  
  // Set color based on type
  switch (type) {
    case 'success':
      toast.style.backgroundColor = '#4caf50';
      break;
    case 'error':
      toast.style.backgroundColor = '#f44336';
      break;
    default:
      toast.style.backgroundColor = '#2196f3';
  }
  
  // Add message
  toast.textContent = message;
  
  // Add to body
  document.body.appendChild(toast);
  
  // Auto-hide success/error toast after 5 seconds
  if (type !== 'info') {
    setTimeout(() => {
      hideToast(toast);
    }, 5000);
  }
  
  return toast;
};

/**
 * Hide a toast notification
 * @param {HTMLElement} toast - The toast element to hide
 */
const hideToast = (toast) => {
  if (toast && toast.parentNode) {
    toast.parentNode.removeChild(toast);
  }
};